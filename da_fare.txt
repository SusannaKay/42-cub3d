âœ… Creare struttura dati principale t_game che contiene: map, graphics, player, MLX.

ğŸ“‚ Fase 1 â€“ Parsing della mappa .cub

- [âœ…] Aprire il file `.cub` con `open`, fallire con `error_exit` se la syscall non riesce.
- [âœ…] Leggere il file con `get_next_line`, normalizzare le righe (trim destro) e saltare righe vuote finchÃ© non servono.
- [âœ…] Implementare `parse_textures` per riconoscere `NO/SO/WE/EA`, salvare path senza spazi iniziali e bloccare i duplicati.
- [âœ…] Verificare che i file delle texture siano accessibili (`open`/`close`) prima di salvarli.
- [ ] Implementare un helper `parse_rgb` che splitta `F` e `C` su `,`, converte in int e valida range 0-255.
- [ ] Assicurare che `graphics->floor` e `graphics->ceiling` vengano valorizzati una sola volta e segnalare errori di duplicati.
- [ ] Quando compare una riga di mappa, impostare `map->in_map` e salvare tutte le righe successive (inclusi spazi) in `map->map`.
- [ ] Aggiornare `map->width` e `map->height`, normalizzando le righe piÃ¹ corte con spazi per ottenere una matrice rettangolare.
- [ ] Controllare che ogni riga della mappa contenga solo caratteri validi (`0`, `1`, `N`, `S`, `E`, `W` e spazi).
- [ ] Identificare posizione e direzione del player, trasferendo le coordinate in `t_player` e assicurandosi che ce ne sia uno solo.
- [ ] Implementare il controllo di chiusura della mappa (nessun `0` esposto a spazi o fuori mappa).
- [ ] Gestire gli errori liberando le risorse e stampando `Error\n<msg>` tramite `error_exit`.


ğŸ¨ Fase 2 â€“ Setup grafica

âœ… Inizializzare finestra MLX (mlx_init, mlx_new_window).

 Caricare texture con mlx_xpm_file_to_image.

 Creare image buffer (mlx_new_image) per disegnare pixel.

 Funzione per convertire (r,g,b) in int32.

ğŸ§­ Fase 3 â€“ Player e movimenti

 Struttura t_player con posizione (x,y), direzione (dx,dy), piano camera.

 Inizializzare direzione in base al carattere di spawn (N,S,E,W).

 Gestire input tastiera:

W/A/S/D â†’ movimento avanti/indietro/laterale.

â†/â†’ â†’ rotazione camera.

ESC â†’ exit clean.

 Collisioni con i muri (blocco movimento se tile=1).

ğŸ”¦ Fase 4 â€“ Raycasting

 Implementare algoritmo DDA:

Per ogni colonna di pixel della finestra â†’ calcolare rayDir.

Trovare distanza al primo muro (stepX, stepY).

Calcolare distanza corretta (per evitare fish-eye).

 Disegnare linea verticale in base allâ€™altezza del muro.

 Applicare la texture giusta in base al lato colpito (N,S,E,W).

ğŸŒˆ Fase 5 â€“ Floor e Ceiling

 Riempire metÃ  superiore con colore ceiling, metÃ  inferiore con floor.

 Ottimizzare disegno: prima riempire background, poi disegnare muri.

ğŸ§¹ Fase 6 â€“ Pulizia e gestione memoria

 Free di texture, mappa, finestra MLX.

 Chiudere programma con X sulla finestra.

 Controllo Valgrind: nessuna perdita di memoria.